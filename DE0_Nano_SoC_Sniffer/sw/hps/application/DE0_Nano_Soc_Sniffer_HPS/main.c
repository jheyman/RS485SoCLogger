#include <assert.h>
#include <errno.h>
#include <fcntl.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>
#include <unistd.h>
#include <stdio.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <strings.h>
#include <fcntl.h>

#include "alt_generalpurpose_io.h"
#include "hwlib.h"
#include "socal/alt_gpio.h"
#include "socal/hps.h"
#include "socal/socal.h"
#include "hps_linux.h"

/* header file generated by sopc-create-header from Quartus/QSys SoC file */
#include "../hps_soc_system.h"

void open_physical_memory_device() {
    fd_dev_mem = open("/dev/mem", O_RDWR | O_SYNC);
    if(fd_dev_mem  == -1) {
        printf("ERROR: could not open \"/dev/mem\".\n");
        printf("    errno = %s\n", strerror(errno));
        exit(EXIT_FAILURE);
    }
}

void close_physical_memory_device() {
    close(fd_dev_mem);
}

void mmap_hps_peripherals() {
    hps_gpio = mmap(NULL, hps_gpio_span, PROT_READ | PROT_WRITE, MAP_SHARED, fd_dev_mem, hps_gpio_ofst);
    if (hps_gpio == MAP_FAILED) {
        printf("Error: hps_gpio mmap() failed.\n");
        printf("    errno = %s\n", strerror(errno));
        close(fd_dev_mem);
        exit(EXIT_FAILURE);
    }
}

void munmap_hps_peripherals() {
    if (munmap(hps_gpio, hps_gpio_span) != 0) {
        printf("Error: hps_gpio munmap() failed\n");
        printf("    errno = %s\n", strerror(errno));
        close(fd_dev_mem);
        exit(EXIT_FAILURE);
    }

    hps_gpio = NULL;
}

void mmap_hps_RAMs() {
	RAMDest_UART_RX[0] = mmap(NULL, RAMDEST_UART0_RX_END - RAMDEST_UART0_RX_START + 1, PROT_READ | PROT_WRITE, MAP_SHARED, fd_dev_mem, RAMDEST_UART0_RX_START);
    if (RAMDest_UART_RX[0] == MAP_FAILED) {
        printf("Error: RAMDest_UART0 mmap() failed.\n");
        printf("    errno = %s\n", strerror(errno));
        close(fd_dev_mem);
        exit(EXIT_FAILURE);
    }

	RAMDest_UART_RX[1] = mmap(NULL, RAMDEST_UART1_RX_END-RAMDEST_UART1_RX_START+1, PROT_READ | PROT_WRITE, MAP_SHARED, fd_dev_mem, RAMDEST_UART1_RX_START);
    if (RAMDest_UART_RX[1] == MAP_FAILED) {
        printf("Error: RAMDest_UART1 mmap() failed.\n");
        printf("    errno = %s\n", strerror(errno));
        close(fd_dev_mem);
        exit(EXIT_FAILURE);
    }

    RAMDest_UART_RX[2] = mmap(NULL, RAMDEST_UART2_RX_END-RAMDEST_UART2_RX_START+1, PROT_READ | PROT_WRITE, MAP_SHARED, fd_dev_mem, RAMDEST_UART2_RX_START);
    if (RAMDest_UART_RX[2] == MAP_FAILED) {
        printf("Error: RAMDest_UART2 mmap() failed.\n");
        printf("    errno = %s\n", strerror(errno));
        close(fd_dev_mem);
        exit(EXIT_FAILURE);
    }

    RAMDest_UART_RX[3] = mmap(NULL, RAMDEST_UART3_RX_END-RAMDEST_UART3_RX_START+1, PROT_READ | PROT_WRITE, MAP_SHARED, fd_dev_mem, RAMDEST_UART3_RX_START);
    if (RAMDest_UART_RX[3] == MAP_FAILED) {
        printf("Error: RAMDest_UART3 mmap() failed.\n");
        printf("    errno = %s\n", strerror(errno));
        close(fd_dev_mem);
        exit(EXIT_FAILURE);
    }

    RAMDest_UART_RX[4] = mmap(NULL, RAMDEST_UART4_RX_END-RAMDEST_UART4_RX_START+1, PROT_READ | PROT_WRITE, MAP_SHARED, fd_dev_mem, RAMDEST_UART4_RX_START);
    if (RAMDest_UART_RX[4] == MAP_FAILED) {
        printf("Error: RAMDest_UART4 mmap() failed.\n");
        printf("    errno = %s\n", strerror(errno));
        close(fd_dev_mem);
        exit(EXIT_FAILURE);
    }

    RAMDest_UART_RX[5] = mmap(NULL, RAMDEST_UART5_RX_END-RAMDEST_UART5_RX_START+1, PROT_READ | PROT_WRITE, MAP_SHARED, fd_dev_mem, RAMDEST_UART5_RX_START);
    if (RAMDest_UART_RX[5] == MAP_FAILED) {
        printf("Error: RAMDest_UART5 mmap() failed.\n");
        printf("    errno = %s\n", strerror(errno));
        close(fd_dev_mem);
        exit(EXIT_FAILURE);
    }

    RAMDest_UART_Info = mmap(NULL, 128, PROT_READ | PROT_WRITE, MAP_SHARED, fd_dev_mem, RAMDEST_UART_INFO);
    if (RAMDest_UART_Info == MAP_FAILED) {
        printf("Error: RAMDest_UART_Info mmap() failed.\n");
        printf("    errno = %s\n", strerror(errno));
        close(fd_dev_mem);
        exit(EXIT_FAILURE);
    }
}

void munmap_hps_RAMs() {
    if (munmap(RAMDest_UART_RX[0], RAMDEST_UART0_RX_END - RAMDEST_UART0_RX_START + 1) != 0) {
        printf("Error: RAMDest_UART0 munmap() failed\n");
        printf("    errno = %s\n", strerror(errno));
        close(fd_dev_mem);
        exit(EXIT_FAILURE);
    }

    if (munmap(RAMDest_UART_RX[1], RAMDEST_UART1_RX_END-RAMDEST_UART1_RX_START+1) != 0) {
        printf("Error: RAMDest_UART1 munmap() failed\n");
        printf("    errno = %s\n", strerror(errno));
        close(fd_dev_mem);
        exit(EXIT_FAILURE);
    }

    if (munmap(RAMDest_UART_RX[2], RAMDEST_UART2_RX_END-RAMDEST_UART2_RX_START+1) != 0) {
        printf("Error: RAMDest_UART2 munmap() failed\n");
        printf("    errno = %s\n", strerror(errno));
        close(fd_dev_mem);
        exit(EXIT_FAILURE);
    }

    if (munmap(RAMDest_UART_RX[3], RAMDEST_UART3_RX_END-RAMDEST_UART3_RX_START+1) != 0) {
        printf("Error: RAMDest_UART3 munmap() failed\n");
        printf("    errno = %s\n", strerror(errno));
        close(fd_dev_mem);
        exit(EXIT_FAILURE);
    }

    if (munmap(RAMDest_UART_RX[4], RAMDEST_UART4_RX_END-RAMDEST_UART4_RX_START+1) != 0) {
        printf("Error: RAMDest_UART4 munmap() failed\n");
        printf("    errno = %s\n", strerror(errno));
        close(fd_dev_mem);
        exit(EXIT_FAILURE);
    }

    if (munmap(RAMDest_UART_RX[5], RAMDEST_UART5_RX_END-RAMDEST_UART5_RX_START+1) != 0) {
        printf("Error: RAMDest_UART5 munmap() failed\n");
        printf("    errno = %s\n", strerror(errno));
        close(fd_dev_mem);
        exit(EXIT_FAILURE);
    }

    if (munmap(RAMDest_UART_Info, 128) != 0) {
        printf("Error: RAMDest_UART_Info munmap() failed\n");
        printf("    errno = %s\n", strerror(errno));
        close(fd_dev_mem);
        exit(EXIT_FAILURE);
    }

    RAMDest_UART_RX[0] = NULL;
    RAMDest_UART_RX[1] = NULL;
    RAMDest_UART_RX[2] = NULL;
    RAMDest_UART_RX[3] = NULL;
    RAMDest_UART_RX[4] = NULL;
    RAMDest_UART_RX[5] = NULL;

    RAMDest_UART_Info = NULL;
}

void mmap_fpga_peripherals() {

    h2f_lw_axi_master = mmap(NULL, h2f_lw_axi_master_span, PROT_READ | PROT_WRITE, MAP_SHARED, fd_dev_mem, h2f_lw_axi_master_ofst);
    if (h2f_lw_axi_master == MAP_FAILED) {
        printf("Error: h2f_lw_axi_master mmap() failed.\n");
        printf("    errno = %s\n", strerror(errno));
        close(fd_dev_mem);
        exit(EXIT_FAILURE);
    }

    fpga_leds = h2f_lw_axi_master + HPS_FPGA_LEDS_BASE;
}

void munmap_fpga_peripherals() {
    if (munmap(h2f_lw_axi_master, h2f_lw_axi_master_span) != 0) {
        printf("Error: h2f_lw_axi_master munmap() failed\n");
        printf("    errno = %s\n", strerror(errno));
        close(fd_dev_mem);
        exit(EXIT_FAILURE);
    }

    h2f_lw_axi_master = NULL;
    fpga_leds         = NULL;
}

void mmap_peripherals() {
    mmap_hps_peripherals();
    mmap_fpga_peripherals();
    mmap_hps_RAMs();
}

void munmap_peripherals() {
    munmap_hps_peripherals();
    munmap_fpga_peripherals();
    munmap_hps_RAMs();
}

void setup_hps_gpio() {
    // Initialize the HPS PIO controller:
    //     Set the direction of the HPS_LED GPIO bit to "output"
    //     Set the direction of the HPS_KEY_N GPIO bit to "input"
    void *hps_gpio_direction = ALT_GPIO_SWPORTA_DDR_ADDR(hps_gpio);
    alt_setbits_word(hps_gpio_direction, ALT_GPIO_PIN_OUTPUT << HPS_LED_PORT_BIT);
    alt_setbits_word(hps_gpio_direction, ALT_GPIO_PIN_INPUT << HPS_KEY_N_PORT_BIT);
}

bool read_hps_key() {
    void *hps_gpio_port = ALT_GPIO_EXT_PORTA_ADDR(hps_gpio);
    uint32_t hps_gpio_input = alt_read_word(hps_gpio_port) & HPS_KEY_N_MASK;
    // HPS_KEY_N is active-low
    return (~hps_gpio_input & HPS_KEY_N_MASK);
}

void toggle_hps_led() {
    void *hps_gpio_data = ALT_GPIO_SWPORTA_DR_ADDR(hps_gpio);
	uint32_t hps_led_value = alt_read_word(hps_gpio_data);
	hps_led_value >>= HPS_LED_PORT_BIT;
	hps_led_value = !hps_led_value;
	hps_led_value <<= HPS_LED_PORT_BIT;
	alt_replbits_word(hps_gpio_data, HPS_LED_MASK, hps_led_value);
}

void setup_fpga_leds() {
    alt_write_word(fpga_leds, 0x0001);
}

void toggle_fpga_leds() {
	uint32_t leds = alt_read_word(fpga_leds);
	leds = ~leds;
	alt_write_word(fpga_leds, leds);
}

void clear_leds() {
    alt_write_word(fpga_leds, 0x0000);
}

void set_leds() {
    alt_write_word(fpga_leds, 0x0002);
}

typedef struct {
	char* RXBaseAddress[6];
	char* RXTopAddress[6];
	uint32_t RXFrameSize[6];
	uint32_t RXTimeStampSize[6];
	uint32_t RXFrameLengthSize[6];
	char* RXNextFrameAddress[6];
} UART_RXinfo;

unsigned int RXLatestTransferedFrameOffset[6];
unsigned int RXLatestReceivedFrameOffset[6];
unsigned int RXStat_NbReceivedFrames[6];
unsigned int MaxFrameOffset[6];
unsigned int topGap[6];

int main() {
	unsigned int i/*,k*/;
	printf("\e[2J");
    printf("DE0-Nano-SoC Sniffer HPS-side compiled %s %s\n", __DATE__, __TIME__);

    open_physical_memory_device();
    mmap_peripherals();

    setup_hps_gpio();
    setup_fpga_leds();

    UART_RXinfo* info = RAMDest_UART_Info;

    // Initially, point to wherever the RX buffer FPGA pointer is
    // (i.e. disregard frames that may have arrived in the buffer before this program is executed)
	for (i=0;i<6;i++)
	{
		// Since size of (data frame + timestamp) is not necessarily a divider of the buffer size, compute the number
		// of full frames storable, and the remaining gap of bytes between the end of the last frame and the top address
		topGap[i] = (info->RXTopAddress[i] - info->RXBaseAddress[i] + 1)%(info->RXFrameSize[i] + info->RXTimeStampSize[i]+info->RXFrameLengthSize[i]);

		//printf("topGap%d=%d\n", i, topGap[i]);

		MaxFrameOffset[i] = info->RXTopAddress[i] - info->RXBaseAddress[i] + 1 - topGap[i];

		RXStat_NbReceivedFrames[i] = 0;

		//printf("MaxFrameOffset%d=%d\n", i, MaxFrameOffset[i]);

		//printf("RXBaseAddress%d=%p\n", i, info->RXBaseAddress[i]);
		//printf("RXTopAddress%d=%p\n", i, info->RXTopAddress[i]);
		//printf("RXNextFrameAddress%d=%p\n", i, info->RXNextFrameAddress[i]);
		//printf("frame size = %u\n", info->RXFrameSize[i]);
		//printf("timestamp size = %u\n",info->RXTimeStampSize[i]);
		//printf("framelength size = %u\n", info->RXFrameLengthSize[i]);

		if (info->RXNextFrameAddress[i] == info->RXBaseAddress[i])
			RXLatestReceivedFrameOffset[i] = info->RXTopAddress[i]+1 - topGap[i] - info->RXFrameSize[i] - info->RXTimeStampSize[i] - info->RXFrameLengthSize[i] - info->RXBaseAddress[i];
       	else
       		RXLatestReceivedFrameOffset[i] = info->RXNextFrameAddress[i] - info->RXFrameSize[i] - info->RXTimeStampSize[i] - info->RXFrameLengthSize[i] - info->RXBaseAddress[i];

		RXLatestTransferedFrameOffset[i] = RXLatestReceivedFrameOffset[i];
		//printf("UART%d: initial RXTransferFrameOffset=%d\n", i, RXLatestTransferedFrameOffset[i]);
	}

	// UDP socket initialization
	struct sockaddr_in servaddr;
    int fd = socket(AF_INET,SOCK_DGRAM,IPPROTO_UDP);
    if(fd<0){
        perror("cannot open socket");
    }

    bzero(&servaddr,sizeof(servaddr));
    servaddr.sin_family = AF_INET;
    servaddr.sin_addr.s_addr = htonl(INADDR_BROADCAST);
    servaddr.sin_port = htons(8888);

    // Enabling broadcast option is required by POSIX, and Linux enforces it
    int broadcastEnable=1;
    int ret=setsockopt(fd, SOL_SOCKET, SO_BROADCAST, &broadcastEnable, sizeof(broadcastEnable));
    if (ret !=0) {
    	perror("cannot set socket in broadcast mode");
    }

    unsigned long ethMsgIndex = 0;
    unsigned long loopIndex = 0;
    bool receivedStuff=false;

    // Main scanning loop
    while (true) {

    	// Scan memory buffers for all channels
        for (i=0;i<6;i++)
		{
        	// handle buffer rollover: if next frame is at base address, then the latest received frame must have been in the last position
        	// at the top of the buffer
        	if (info->RXNextFrameAddress[i] == info->RXBaseAddress[i])
        		RXLatestReceivedFrameOffset[i] = info->RXTopAddress[i]+1 - topGap[i] - info->RXFrameSize[i] - info->RXTimeStampSize[i] - info->RXFrameLengthSize[i] - info->RXBaseAddress[i];
        	// else, just look one frame size lower than the nextFrame address
        	else
        		RXLatestReceivedFrameOffset[i] = info->RXNextFrameAddress[i] - info->RXFrameSize[i] - info->RXTimeStampSize[i] - info->RXFrameLengthSize[i] - info->RXBaseAddress[i];

        	// Then catch-up by transferring all pending messages
        	if (RXLatestReceivedFrameOffset[i] != RXLatestTransferedFrameOffset[i])
        	{
        		receivedStuff = true;
        		int nb_Frames_received = RXLatestTransferedFrameOffset[i] < RXLatestReceivedFrameOffset[i] ?
        				(RXLatestReceivedFrameOffset[i] - RXLatestTransferedFrameOffset[i])/ (info->RXFrameSize[i]+info->RXTimeStampSize[i]+info->RXFrameLengthSize[i]):
						(MaxFrameOffset[i] - RXLatestTransferedFrameOffset[i])/ (info->RXFrameSize[i]+info->RXTimeStampSize[i]+info->RXFrameLengthSize[i]) + RXLatestReceivedFrameOffset[i]/(info->RXFrameSize[i]+info->RXTimeStampSize[i]+info->RXFrameLengthSize[i]);

        		//printf("Got %d frames on channel %d\n", nb_Frames_received, i);

        		// Flush all pending messages
        		while( RXLatestTransferedFrameOffset[i] != RXLatestReceivedFrameOffset[i])
        		{
        			RXStat_NbReceivedFrames[i]++;

        			// Determine where next frame is
        			RXLatestTransferedFrameOffset[i] += info->RXFrameSize[i] + info->RXTimeStampSize[i] + info->RXFrameLengthSize[i];

        			// rollover
        			if (RXLatestTransferedFrameOffset[i] >= MaxFrameOffset[i]) RXLatestTransferedFrameOffset[i] = 0;
        			//printf("UART%d: RXTransferFrameOffset=%d\n", i, RXLatestTransferedFrameOffset[i]);

        			// Figure out logical addresses
        			char* frameAddr = RAMDest_UART_RX[i] + RXLatestTransferedFrameOffset[i];
        			char* timestampAddr = frameAddr + info->RXFrameSize[i];
        			char* frameLengthAddr = timestampAddr + info->RXTimeStampSize[i];

            		//printf("timestamp = %llu\n",*(unsigned long long*)timestampAddr);

            		unsigned int frameLength = *(unsigned int*)frameLengthAddr;
            		//printf("frameLength = %u\n",frameLength);

            		/*
        	    	char* addr;
        	    	addr = frameAddr;
        	    	for (k=0;k<frameLength;k++)
        	    	{
        	    		printf("%02X ", *addr);
        	    		addr++;
        	    	}
        	    	printf("\n");
            		*/

        			char bufToSend[1500];

        			sprintf(bufToSend, "%015lu:", *(unsigned long*)timestampAddr);
       			    sprintf(bufToSend+16, "%04lu:", ethMsgIndex);
       			    sprintf(bufToSend+21, "%02u:", i);
       			    sprintf(bufToSend+24, "%04u:", frameLength);
       			    memcpy(bufToSend+29, frameAddr, 1024);

            		// Push frame to Ethernet
        		    if (sendto(fd, bufToSend, 16+5+3+5+frameLength, 0, (struct sockaddr*)&servaddr, sizeof(servaddr)) < 0){
        		        perror("cannot send message");
        		    }

        			//printf("pushed one frame from channel %d\n", i);

        			ethMsgIndex++ ;
        		    if (ethMsgIndex > 999) ethMsgIndex = 0;
        		}
        	}
		}

        if (receivedStuff)
        {
        	printf("\e[2;0f");
        	printf("%7s %10s\n", "channel", "nbReceived");

        	for (i=0;i<6;i++)
        	{
        		printf("%7d %10u\n", i, RXStat_NbReceivedFrames[i]);
        	}
        	receivedStuff = false;
        }

    	toggle_fpga_leds();
    	usleep(ALT_MICROSECS_IN_A_SEC);
        loopIndex++;
    }

    munmap_peripherals();
    close_physical_memory_device();
    close(fd);

    return 0;
}
