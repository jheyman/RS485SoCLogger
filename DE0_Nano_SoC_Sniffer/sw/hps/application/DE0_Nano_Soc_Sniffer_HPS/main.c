#include <assert.h>
#include <errno.h>
#include <fcntl.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>
#include <unistd.h>
#include <stdio.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <strings.h>
#include <fcntl.h>

#include "alt_generalpurpose_io.h"
#include "hwlib.h"
#include "socal/alt_gpio.h"
#include "socal/hps.h"
#include "socal/socal.h"
#include "hps_linux.h"

/* header file generated by sopc-create-header from Quartus/QSys SoC file */
#include "../hps_soc_system.h"

#define ETH_MAX_PACKET_SIZE 1500

#define ETH_FRAME_INFO_SIZE 26
#define ETH_PACKET_INDEX_SIZE 1
// Format:
// 16 bytes for timestamp
// 4 bytes for ethIndex
// 2 bytes for channel index
// 4 bytes for frameLength


void open_physical_memory_device() {
    fd_dev_mem = open("/dev/mem", O_RDWR | O_SYNC);
    if(fd_dev_mem  == -1) {
        printf("ERROR: could not open \"/dev/mem\".\n");
        printf("    errno = %s\n", strerror(errno));
        exit(EXIT_FAILURE);
    }
}

void close_physical_memory_device() {
    close(fd_dev_mem);
}

void mmap_hps_peripherals() {
    hps_gpio = mmap(NULL, hps_gpio_span, PROT_READ | PROT_WRITE, MAP_SHARED, fd_dev_mem, hps_gpio_ofst);
    if (hps_gpio == MAP_FAILED) {
        printf("Error: hps_gpio mmap() failed.\n");
        printf("    errno = %s\n", strerror(errno));
        close(fd_dev_mem);
        exit(EXIT_FAILURE);
    }
}

void munmap_hps_peripherals() {
    if (munmap(hps_gpio, hps_gpio_span) != 0) {
        printf("Error: hps_gpio munmap() failed\n");
        printf("    errno = %s\n", strerror(errno));
        close(fd_dev_mem);
        exit(EXIT_FAILURE);
    }

    hps_gpio = NULL;
}

void mmap_hps_RAMs() {
	RAMDest_UART_RX[0] = mmap(NULL, RAMDEST_UART0_RX_END - RAMDEST_UART0_RX_START + 1, PROT_READ | PROT_WRITE, MAP_SHARED, fd_dev_mem, RAMDEST_UART0_RX_START);
    if (RAMDest_UART_RX[0] == MAP_FAILED) {
        printf("Error: RAMDest_UART0 mmap() failed.\n");
        printf("    errno = %s\n", strerror(errno));
        close(fd_dev_mem);
        exit(EXIT_FAILURE);
    }

	RAMDest_UART_RX[1] = mmap(NULL, RAMDEST_UART1_RX_END-RAMDEST_UART1_RX_START+1, PROT_READ | PROT_WRITE, MAP_SHARED, fd_dev_mem, RAMDEST_UART1_RX_START);
    if (RAMDest_UART_RX[1] == MAP_FAILED) {
        printf("Error: RAMDest_UART1 mmap() failed.\n");
        printf("    errno = %s\n", strerror(errno));
        close(fd_dev_mem);
        exit(EXIT_FAILURE);
    }

    RAMDest_UART_RX[2] = mmap(NULL, RAMDEST_UART2_RX_END-RAMDEST_UART2_RX_START+1, PROT_READ | PROT_WRITE, MAP_SHARED, fd_dev_mem, RAMDEST_UART2_RX_START);
    if (RAMDest_UART_RX[2] == MAP_FAILED) {
        printf("Error: RAMDest_UART2 mmap() failed.\n");
        printf("    errno = %s\n", strerror(errno));
        close(fd_dev_mem);
        exit(EXIT_FAILURE);
    }

    RAMDest_UART_RX[3] = mmap(NULL, RAMDEST_UART3_RX_END-RAMDEST_UART3_RX_START+1, PROT_READ | PROT_WRITE, MAP_SHARED, fd_dev_mem, RAMDEST_UART3_RX_START);
    if (RAMDest_UART_RX[3] == MAP_FAILED) {
        printf("Error: RAMDest_UART3 mmap() failed.\n");
        printf("    errno = %s\n", strerror(errno));
        close(fd_dev_mem);
        exit(EXIT_FAILURE);
    }

    RAMDest_UART_RX[4] = mmap(NULL, RAMDEST_UART4_RX_END-RAMDEST_UART4_RX_START+1, PROT_READ | PROT_WRITE, MAP_SHARED, fd_dev_mem, RAMDEST_UART4_RX_START);
    if (RAMDest_UART_RX[4] == MAP_FAILED) {
        printf("Error: RAMDest_UART4 mmap() failed.\n");
        printf("    errno = %s\n", strerror(errno));
        close(fd_dev_mem);
        exit(EXIT_FAILURE);
    }

    RAMDest_UART_RX[5] = mmap(NULL, RAMDEST_UART5_RX_END-RAMDEST_UART5_RX_START+1, PROT_READ | PROT_WRITE, MAP_SHARED, fd_dev_mem, RAMDEST_UART5_RX_START);
    if (RAMDest_UART_RX[5] == MAP_FAILED) {
        printf("Error: RAMDest_UART5 mmap() failed.\n");
        printf("    errno = %s\n", strerror(errno));
        close(fd_dev_mem);
        exit(EXIT_FAILURE);
    }

    RAMDest_UART_Info_UART0 = mmap(NULL, 128, PROT_READ | PROT_WRITE, MAP_SHARED, fd_dev_mem, RAMDEST_UART_RXINFO_UART0);
    if (RAMDest_UART_Info_UART0 == MAP_FAILED) {
        printf("Error: RAMDest_UART_Info_UART0 mmap() failed.\n");
        printf("    errno = %s\n", strerror(errno));
        close(fd_dev_mem);
        exit(EXIT_FAILURE);
    }

    RAMDest_UART_Info_UART1 = mmap(NULL, 128, PROT_READ | PROT_WRITE, MAP_SHARED, fd_dev_mem, RAMDEST_UART_RXINFO_UART1);
    if (RAMDest_UART_Info_UART1 == MAP_FAILED) {
        printf("Error: RAMDest_UART_Info_UART1 mmap() failed.\n");
        printf("    errno = %s\n", strerror(errno));
        close(fd_dev_mem);
        exit(EXIT_FAILURE);
    }
}

void munmap_hps_RAMs() {
    if (munmap(RAMDest_UART_RX[0], RAMDEST_UART0_RX_END - RAMDEST_UART0_RX_START + 1) != 0) {
        printf("Error: RAMDest_UART0 munmap() failed\n");
        printf("    errno = %s\n", strerror(errno));
        close(fd_dev_mem);
        exit(EXIT_FAILURE);
    }

    if (munmap(RAMDest_UART_RX[1], RAMDEST_UART1_RX_END-RAMDEST_UART1_RX_START+1) != 0) {
        printf("Error: RAMDest_UART1 munmap() failed\n");
        printf("    errno = %s\n", strerror(errno));
        close(fd_dev_mem);
        exit(EXIT_FAILURE);
    }

    if (munmap(RAMDest_UART_RX[2], RAMDEST_UART2_RX_END-RAMDEST_UART2_RX_START+1) != 0) {
        printf("Error: RAMDest_UART2 munmap() failed\n");
        printf("    errno = %s\n", strerror(errno));
        close(fd_dev_mem);
        exit(EXIT_FAILURE);
    }

    if (munmap(RAMDest_UART_RX[3], RAMDEST_UART3_RX_END-RAMDEST_UART3_RX_START+1) != 0) {
        printf("Error: RAMDest_UART3 munmap() failed\n");
        printf("    errno = %s\n", strerror(errno));
        close(fd_dev_mem);
        exit(EXIT_FAILURE);
    }

    if (munmap(RAMDest_UART_RX[4], RAMDEST_UART4_RX_END-RAMDEST_UART4_RX_START+1) != 0) {
        printf("Error: RAMDest_UART4 munmap() failed\n");
        printf("    errno = %s\n", strerror(errno));
        close(fd_dev_mem);
        exit(EXIT_FAILURE);
    }

    if (munmap(RAMDest_UART_RX[5], RAMDEST_UART5_RX_END-RAMDEST_UART5_RX_START+1) != 0) {
        printf("Error: RAMDest_UART5 munmap() failed\n");
        printf("    errno = %s\n", strerror(errno));
        close(fd_dev_mem);
        exit(EXIT_FAILURE);
    }

    if (munmap(RAMDest_UART_Info_UART0, 128) != 0) {
        printf("Error: RAMDest_UART_Info_UART0 munmap() failed\n");
        printf("    errno = %s\n", strerror(errno));
        close(fd_dev_mem);
        exit(EXIT_FAILURE);
    }

    if (munmap(RAMDest_UART_Info_UART1, 128) != 0) {
        printf("Error: RAMDest_UART_Info_UART1 munmap() failed\n");
        printf("    errno = %s\n", strerror(errno));
        close(fd_dev_mem);
        exit(EXIT_FAILURE);
    }

    RAMDest_UART_RX[0] = NULL;
    RAMDest_UART_RX[1] = NULL;
    RAMDest_UART_RX[2] = NULL;
    RAMDest_UART_RX[3] = NULL;
    RAMDest_UART_RX[4] = NULL;
    RAMDest_UART_RX[5] = NULL;

    RAMDest_UART_Info_UART0 = NULL;
    RAMDest_UART_Info_UART1 = NULL;
}

void mmap_fpga_peripherals() {

    h2f_lw_axi_master = mmap(NULL, h2f_lw_axi_master_span, PROT_READ | PROT_WRITE, MAP_SHARED, fd_dev_mem, h2f_lw_axi_master_ofst);
    if (h2f_lw_axi_master == MAP_FAILED) {
        printf("Error: h2f_lw_axi_master mmap() failed.\n");
        printf("    errno = %s\n", strerror(errno));
        close(fd_dev_mem);
        exit(EXIT_FAILURE);
    }

    fpga_leds = h2f_lw_axi_master + HPS_FPGA_LEDS_BASE;
}

void munmap_fpga_peripherals() {
    if (munmap(h2f_lw_axi_master, h2f_lw_axi_master_span) != 0) {
        printf("Error: h2f_lw_axi_master munmap() failed\n");
        printf("    errno = %s\n", strerror(errno));
        close(fd_dev_mem);
        exit(EXIT_FAILURE);
    }

    h2f_lw_axi_master = NULL;
    fpga_leds         = NULL;
}

void mmap_peripherals() {
    mmap_hps_peripherals();
    mmap_fpga_peripherals();
    mmap_hps_RAMs();
}

void munmap_peripherals() {
    munmap_hps_peripherals();
    munmap_fpga_peripherals();
    munmap_hps_RAMs();
}

void setup_hps_gpio() {
    // Initialize the HPS PIO controller:
    //     Set the direction of the HPS_LED GPIO bit to "output"
    //     Set the direction of the HPS_KEY_N GPIO bit to "input"
    void *hps_gpio_direction = ALT_GPIO_SWPORTA_DDR_ADDR(hps_gpio);
    alt_setbits_word(hps_gpio_direction, ALT_GPIO_PIN_OUTPUT << HPS_LED_PORT_BIT);
    alt_setbits_word(hps_gpio_direction, ALT_GPIO_PIN_INPUT << HPS_KEY_N_PORT_BIT);
}

bool read_hps_key() {
    void *hps_gpio_port = ALT_GPIO_EXT_PORTA_ADDR(hps_gpio);
    uint32_t hps_gpio_input = alt_read_word(hps_gpio_port) & HPS_KEY_N_MASK;
    // HPS_KEY_N is active-low
    return (~hps_gpio_input & HPS_KEY_N_MASK);
}

void toggle_hps_led() {
    void *hps_gpio_data = ALT_GPIO_SWPORTA_DR_ADDR(hps_gpio);
	uint32_t hps_led_value = alt_read_word(hps_gpio_data);
	hps_led_value >>= HPS_LED_PORT_BIT;
	hps_led_value = !hps_led_value;
	hps_led_value <<= HPS_LED_PORT_BIT;
	alt_replbits_word(hps_gpio_data, HPS_LED_MASK, hps_led_value);
}

void setup_fpga_leds() {
    alt_write_word(fpga_leds, 0x0001);
}

void toggle_fpga_leds() {
	uint32_t leds = alt_read_word(fpga_leds);
	leds = ~leds;
	alt_write_word(fpga_leds, leds);
}

void clear_leds() {
    alt_write_word(fpga_leds, 0x0000);
}

void set_leds() {
    alt_write_word(fpga_leds, 0x0002);
}

typedef struct {
	char* RXBaseAddress;
	char* RXTopAddress;
	uint32_t RXFrameSize;
	uint32_t RXTimeStampSize;
	uint32_t RXFrameLengthSize;
	char* RXNextFrameAddress;
} UART_RXinfo;

unsigned int RXLatestTransferedFrameOffset[6];
unsigned int RXLatestReceivedFrameOffset[6];
unsigned long RXStat_NbReceivedFrames[6];
unsigned char EthPacketIndex = 0;
unsigned int MaxFrameOffset[6];
unsigned int topGap[6];

int main() {
	unsigned int i,j,k;
	printf("\e[2J");
    printf("DE0-Nano-SoC Sniffer HPS-side compiled %s %s\n", __DATE__, __TIME__);

    open_physical_memory_device();
    mmap_peripherals();

    setup_hps_gpio();
    setup_fpga_leds();

    UART_RXinfo* info_UART[6];
    info_UART[0] = RAMDest_UART_Info_UART0 ;
    info_UART[1] = RAMDest_UART_Info_UART1 ;

    // Initially, point to wherever the RX buffer FPGA pointer is
    // (i.e. disregard frames that may have arrived in the buffer before this program is executed)
	for (i=0;i<2;i++)
	{
		UART_RXinfo* info = info_UART[i];

		// Since size of (data frame + timestamp) is not necessarily a divider of the buffer size, compute the number
		// of full frames storable, and the remaining gap of bytes between the end of the last frame and the top address
		topGap[i] = (info->RXTopAddress - info->RXBaseAddress + 1)%(info->RXFrameSize + info->RXTimeStampSize+info->RXFrameLengthSize);

		printf("topGap%d=%d\n", i, topGap[i]);

		MaxFrameOffset[i] = info->RXTopAddress - info->RXBaseAddress + 1 - topGap[i];

		RXStat_NbReceivedFrames[i] = 0;

		printf("MaxFrameOffset%d=%d\n", i, MaxFrameOffset[i]);

		printf("RXBaseAddress%d=%p\n", i, info->RXBaseAddress);
		printf("RXTopAddress%d=%p\n", i, info->RXTopAddress);
		printf("RXNextFrameAddress%d=%p\n", i, info->RXNextFrameAddress);
		printf("frame size = %u\n", info->RXFrameSize);
		printf("timestamp size = %u\n",info->RXTimeStampSize);
		printf("framelength size = %u\n", info->RXFrameLengthSize);

		if (info->RXNextFrameAddress == info->RXBaseAddress)
		{
			RXLatestReceivedFrameOffset[i] = info->RXTopAddress+1 - topGap[i] - info->RXFrameSize - info->RXTimeStampSize - info->RXFrameLengthSize - info->RXBaseAddress;
			printf("UART%d: initial1 RXLatestReceivedFrameOffset=%d\n", i, RXLatestReceivedFrameOffset[i]);
		}
       	else
       	{
       		RXLatestReceivedFrameOffset[i] = info->RXNextFrameAddress - info->RXFrameSize - info->RXTimeStampSize - info->RXFrameLengthSize - info->RXBaseAddress;
			printf("UART%d: initial2 RXLatestReceivedFrameOffset=%d\n", i, RXLatestReceivedFrameOffset[i]);
       	}

		RXLatestTransferedFrameOffset[i] = RXLatestReceivedFrameOffset[i];
		printf("UART%d: initial RXLatestTransferedFrameOffset=%d\n", i, RXLatestTransferedFrameOffset[i]);
	}

	// UDP socket initialization
	struct sockaddr_in servaddr;
    int fd = socket(AF_INET,SOCK_DGRAM,IPPROTO_UDP);
    if(fd<0){
        perror("cannot open socket");
    }

    bzero(&servaddr,sizeof(servaddr));
    servaddr.sin_family = AF_INET;
    servaddr.sin_addr.s_addr = htonl(INADDR_BROADCAST);
    servaddr.sin_port = htons(8888);

    // Enabling broadcast option is required by POSIX, and Linux enforces it
    int broadcastEnable=1;
    int ret=setsockopt(fd, SOL_SOCKET, SO_BROADCAST, &broadcastEnable, sizeof(broadcastEnable));
    if (ret !=0) {
    	perror("cannot set socket in broadcast mode");
    }

	char ethPacketBuffer[ETH_MAX_PACKET_SIZE];
	char* ethPacketPtr=ethPacketBuffer;
    unsigned long MsgIndex = 0;
    unsigned int ethBytesPacked = 0;
    unsigned long loopIndex = 0;

    // Initialize packet index in buffer
	*ethPacketPtr= EthPacketIndex;
	ethPacketPtr++;
	ethBytesPacked++;

    // Main scanning loop
    while (true) {

    	// DEBUG
		//printf("RXNextFrameAddress0=%p\n", info->RXNextFrameAddress[0]);

    	// Scan memory buffers for all channels
        for (i=0;i<2;i++)
		{
        	UART_RXinfo* info = info_UART[i];
        	// handle buffer rollover: if next frame is at base address, then the latest received frame must have been in the last position
        	// at the top of the buffer
        	if (info->RXNextFrameAddress == info->RXBaseAddress)
        		RXLatestReceivedFrameOffset[i] = info->RXTopAddress+1 - topGap[i] - info->RXFrameSize - info->RXTimeStampSize - info->RXFrameLengthSize - info->RXBaseAddress;
        	// else, just look one frame size lower than the nextFrame address
        	else
        		RXLatestReceivedFrameOffset[i] = info->RXNextFrameAddress - info->RXFrameSize - info->RXTimeStampSize - info->RXFrameLengthSize - info->RXBaseAddress;

        	// Then catch-up by transferring all pending messages
        	if (RXLatestReceivedFrameOffset[i] != RXLatestTransferedFrameOffset[i])
        	{
        		//printf("NEW RXLatestReceivedFrameOffset[i] = %d\n",RXLatestReceivedFrameOffset[i]);

        		int nb_Frames_received = RXLatestTransferedFrameOffset[i] < RXLatestReceivedFrameOffset[i] ?
        				(RXLatestReceivedFrameOffset[i] - RXLatestTransferedFrameOffset[i])/ (info->RXFrameSize+info->RXTimeStampSize+info->RXFrameLengthSize):
						(MaxFrameOffset[i] - RXLatestTransferedFrameOffset[i])/ (info->RXFrameSize+info->RXTimeStampSize+info->RXFrameLengthSize) + RXLatestReceivedFrameOffset[i]/(info->RXFrameSize+info->RXTimeStampSize+info->RXFrameLengthSize);

        		RXStat_NbReceivedFrames[i] += nb_Frames_received;
        		printf("Got %d frames on channel %d (total=%lu)\n", nb_Frames_received, i, RXStat_NbReceivedFrames[i]);

        		// Flush all pending messages
        		while( (RXLatestTransferedFrameOffset[i] != RXLatestReceivedFrameOffset[i] ))
        		{
        			// Determine where next frame is
        			RXLatestTransferedFrameOffset[i] += info->RXFrameSize + info->RXTimeStampSize + info->RXFrameLengthSize;

        			// rollover
        			if (RXLatestTransferedFrameOffset[i] >= MaxFrameOffset[i]) RXLatestTransferedFrameOffset[i] = 0;
        			//printf("UART%d: RXTransferFrameOffset=%d\n", i, RXLatestTransferedFrameOffset[i]);

        			// Figure out logical addresses
        			char* frameAddr = RAMDest_UART_RX[i] + RXLatestTransferedFrameOffset[i];
        			char* timestampAddr = frameAddr + info->RXFrameSize;
        			char* frameLengthAddr = timestampAddr + info->RXTimeStampSize;

            		//printf("timestamp = %llu\n",*(unsigned long long*)timestampAddr);

            		unsigned short frameLength = *(unsigned short*)frameLengthAddr;
/*

        	    	char* addr;
        	    	addr = frameAddr;
        	    	for (j=0;j<frameLength/32;j++)
        	    	{
        	    		for (k=0;k<32;k++)
        	    		{
        	    			printf("%02X ", *addr);
        	    			addr++;
        	    		}

        	    		printf("\n");
        	    	}
        	    	for (k=0;k<frameLength%32;k++)
        	    	{
        	    		printf("%02X ", *addr);
        	    		addr++;
        	    	}
    	    		printf("\n");

*/


            		// DEBUG DEBUG DEBUG
            		//if (frameLength != 64)
            		//	printf("ERROR (channel %d): frame is %d long?\n",i, frameLength);

            		//printf("frameLength = %u\n",frameLength);
            		//printf("RXLatestTransferedFrameOffset[i] = %d\n",RXLatestTransferedFrameOffset[i]);
            		//printf("RXLatestReceivedFrameOffset[i] = %d\n",RXLatestReceivedFrameOffset[i]);

            		// Format:
            		// 16 bytes for timestamp
            		// 4 bytes for ethIndex
            		// 2 bytes for channel index
            		// 4 bytes for frameLength
            		// N bytes for data

            		if ((int)frameLength <= (int)(ETH_MAX_PACKET_SIZE - ethBytesPacked - ETH_FRAME_INFO_SIZE))
            		{
            			sprintf(ethPacketPtr, "%016lu", *(unsigned long*)timestampAddr);
            			ethPacketPtr+=16;
           			    sprintf(ethPacketPtr, "%04lu", MsgIndex);
           			    ethPacketPtr+=4;
           			    sprintf(ethPacketPtr, "%02u", i);
           			    ethPacketPtr+=2;
           			    sprintf(ethPacketPtr, "%04u", frameLength);
           			    ethPacketPtr+=4;
           			    memcpy(ethPacketPtr, frameAddr, frameLength);
           			    ethPacketPtr+=frameLength;

            			MsgIndex++ ;
            		    if (MsgIndex > 999) MsgIndex = 0;
           			    ethBytesPacked += ETH_FRAME_INFO_SIZE + frameLength;
           			    //printf("packed %d bytes, remaining %d\n", ethBytesPacked,ETH_MAX_PACKET_SIZE - ethBytesPacked);
            		}
            		else
            		{
                		// Flush buffer to Ethernet first
            		    if (sendto(fd, ethPacketBuffer, ethBytesPacked, 0, (struct sockaddr*)&servaddr, sizeof(servaddr)) < 0){
            		        perror("cannot send message");
            		    }

            		    //printf("flushed buffer, %d bytes\n", ethBytesPacked);

            		    // reset packet buffer management
            		    ethPacketPtr=ethPacketBuffer;
            		    EthPacketIndex++;
            		    *ethPacketPtr= EthPacketIndex;
            			ethPacketPtr++;
            		    ethBytesPacked = 1;

            		    // Then start filling the buffer again
            			sprintf(ethPacketPtr, "%016lu", *(unsigned long*)timestampAddr);
            			ethPacketPtr+=16;
           			    sprintf(ethPacketPtr, "%04lu", MsgIndex);
           			    ethPacketPtr+=4;
           			    sprintf(ethPacketPtr, "%02u", i);
           			    ethPacketPtr+=2;
           			    sprintf(ethPacketPtr, "%04u", frameLength);
           			    ethPacketPtr+=4;
           			    memcpy(ethPacketPtr, frameAddr, frameLength);
           			    ethPacketPtr+=frameLength;

            			MsgIndex++ ;
            		    if (MsgIndex > 999) MsgIndex = 0;
           			    ethBytesPacked += ETH_FRAME_INFO_SIZE + frameLength;
            		}
        		}

        		// All frames have been processed: send the last pending buffer, if any

        		if (ethBytesPacked != 0)
        		{
        			if (sendto(fd, ethPacketBuffer, ethBytesPacked, 0, (struct sockaddr*)&servaddr, sizeof(servaddr)) < 0){
        				perror("cannot send message");
        			}

        			//printf("(final) flushed buffer, %d bytes\n", ethBytesPacked);

        		    // reset packet buffer management
        		    ethPacketPtr=ethPacketBuffer;
        		    EthPacketIndex++;
        		    *ethPacketPtr= EthPacketIndex;
        			ethPacketPtr++;
        		    ethBytesPacked = 1;
        		}
        	}
		}

    	toggle_fpga_leds();
    	usleep(ALT_MICROSECS_IN_A_SEC/2);
        loopIndex++;
    }

    munmap_peripherals();
    close_physical_memory_device();
    close(fd);

    return 0;
}
